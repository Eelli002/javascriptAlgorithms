Divide and Conquer Pattern
    - This pattern involves dividing a data set into smaller chunks and then repeating a process with a subset of data.
    - This pattern can tremendously decrease time complexity.

An Example
    Given a SORTED array of integers, write a function called search, that accepts a value and returns the index where the value passed to the function is located. If the value is not found, return -1
    search([1,2,3,4,5,6], 4) // 3
    search([1,2,3,4,5,6], 6) // 5
    search([1,2,3,4,5,6], 11) // -1

Naive Approach:
function search(arr, val) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === val) {
            return i;
        }
    }
    return -1;
}
// This is linear search and has a time complexity of O(N)

Refactored Method:
function search(array, val) {
    let min = 0;
    let max =  array.length - 1;

    while (min <= max) {
        let middle = Math.floor((min + max) / 2);
        let currentElement = array[middle];

        if (array[middle] < val) {
            min = middle + 1;
        }
        else if (array[middle] > val) {
            max = middle - 1;
        }
        else {
            return middle;
        }
    }
    return -1;
}
// This is binary search and has a time complexity of Log(N)

What it does it insead of looping through every item in the array searching for the value. It will start at the middle and determine if the value is greater or less than the middle. If less than then it will split the array in half, keeping the left side with the lower values. It will repeat this until the number is found. If the value is greater than the middle it will take the right side and do the same thing.

